{
    "id": "CVE-2024-42239",
    "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
    "published": "2024-08-07T16:15:46.733",
    "lastModified": "2024-08-08T14:54:08.330",
    "vulnStatus": "Analyzed",
    "cveTags": [],
    "descriptions": [
        {
            "lang": "en",
            "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Fail bpf_timer_cancel when callback is being cancelled\n\nGiven a schedule:\n\ntimer1 cb\t\t\ttimer2 cb\n\nbpf_timer_cancel(timer2);\tbpf_timer_cancel(timer1);\n\nBoth bpf_timer_cancel calls would wait for the other callback to finish\nexecuting, introducing a lockup.\n\nAdd an atomic_t count named 'cancelling' in bpf_hrtimer. This keeps\ntrack of all in-flight cancellation requests for a given BPF timer.\nWhenever cancelling a BPF timer, we must check if we have outstanding\ncancellation requests, and if so, we must fail the operation with an\nerror (-EDEADLK) since cancellation is synchronous and waits for the\ncallback to finish executing. This implies that we can enter a deadlock\nsituation involving two or more timer callbacks executing in parallel\nand attempting to cancel one another.\n\nNote that we avoid incrementing the cancelling counter for the target\ntimer (the one being cancelled) if bpf_timer_cancel is not invoked from\na callback, to avoid spurious errors. The whole point of detecting\ncur->cancelling and returning -EDEADLK is to not enter a busy wait loop\n(which may or may not lead to a lockup). This does not apply in case the\ncaller is in a non-callback context, the other side can continue to\ncancel as it sees fit without running into errors.\n\nBackground on prior attempts:\n\nEarlier versions of this patch used a bool 'cancelling' bit and used the\nfollowing pattern under timer->lock to publish cancellation status.\n\nlock(t->lock);\nt->cancelling = true;\nmb();\nif (cur->cancelling)\n\treturn -EDEADLK;\nunlock(t->lock);\nhrtimer_cancel(t->timer);\nt->cancelling = false;\n\nThe store outside the critical section could overwrite a parallel\nrequests t->cancelling assignment to true, to ensure the parallely\nexecuting callback observes its cancellation status.\n\nIt would be necessary to clear this cancelling bit once hrtimer_cancel\nis done, but lack of serialization introduced races. Another option was\nexplored where bpf_timer_start would clear the bit when (re)starting the\ntimer under timer->lock. This would ensure serialized access to the\ncancelling bit, but may allow it to be cleared before in-flight\nhrtimer_cancel has finished executing, such that lockups can occur\nagain.\n\nThus, we choose an atomic counter to keep track of all outstanding\ncancellation requests and use it to prevent lockups in case callbacks\nattempt to cancel each other while executing in parallel."
        },
        {
            "lang": "es",
            "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: bpf: falla bpf_timer_cancel cuando se cancela la devoluci\u00f3n de llamada. Dada una programaci\u00f3n: timer1 cb timer2 cb bpf_timer_cancel(timer2); bpf_timer_cancel(timer1); Ambas llamadas a bpf_timer_cancel esperar\u00edan a que la otra devoluci\u00f3n de llamada termine de ejecutarse, introduciendo un bloqueo. Agregue un recuento atomic_t llamado 'cancelaci\u00f3n' en bpf_hrtimer. Esto realiza un seguimiento de todas las solicitudes de cancelaci\u00f3n en vuelo para un temporizador BPF determinado. Siempre que cancelemos un temporizador BPF, debemos verificar si tenemos solicitudes de cancelaci\u00f3n pendientes y, de ser as\u00ed, debemos fallar la operaci\u00f3n con un error (-EDEADLK) ya que la cancelaci\u00f3n es sincr\u00f3nica y espera a que termine de ejecutarse la devoluci\u00f3n de llamada. Esto implica que podemos entrar en una situaci\u00f3n de punto muerto que involucre dos o m\u00e1s devoluciones de llamada de temporizador ejecut\u00e1ndose en paralelo e intentando cancelarse entre s\u00ed. Tenga en cuenta que evitamos incrementar el contador de cancelaci\u00f3n para el temporizador de destino (el que se cancela) si no se invoca bpf_timer_cancel desde una devoluci\u00f3n de llamada, para evitar errores falsos. El objetivo de detectar cur-&gt;cancelar y devolver -EDEADLK es no ingresar a un ciclo de espera ocupado (que puede o no conducir a un bloqueo). Esto no se aplica en caso de que la persona que llama se encuentre en un contexto sin devoluci\u00f3n de llamada; la otra parte puede continuar cancelando como mejor le parezca sin cometer errores. Antecedentes de intentos anteriores: Las versiones anteriores de este parche usaban un bit bool de 'cancelaci\u00f3n' y usaban el siguiente patr\u00f3n en temporizador-&gt;bloqueo para publicar el estado de cancelaci\u00f3n.  lock(t-&gt;lock); t-&gt;cancelling = true; mb(); if (cur-&gt;cancelling) return -EDEADLK; unlock(t-&gt;lock); hrtimer_cancel(t-&gt;timer); t-&gt;cancelling = false; El almac\u00e9n fuera de la secci\u00f3n cr\u00edtica podr\u00eda sobrescribir una asignaci\u00f3n de cancelaci\u00f3n t-&gt;de solicitudes paralelas a verdadero, para garantizar que la devoluci\u00f3n de llamada que se ejecuta en paralelo observe su estado de cancelaci\u00f3n. Ser\u00eda necesario borrar este bit de cancelaci\u00f3n una vez que se complete hrtimer_cancel, pero la falta de serializaci\u00f3n introdujo ejecuciones. Se explor\u00f3 otra opci\u00f3n donde bpf_timer_start borrar\u00eda el bit al (re)iniciar el temporizador bajo temporizador-&gt;bloqueo. Esto garantizar\u00eda el acceso serializado al bit de cancelaci\u00f3n, pero puede permitir que se borre antes de que hrtimer_cancel en vuelo haya terminado de ejecutarse, de modo que los bloqueos puedan ocurrir nuevamente. Por lo tanto, elegimos un contador at\u00f3mico para realizar un seguimiento de todas las solicitudes de cancelaci\u00f3n pendientes y lo utilizamos para evitar bloqueos en caso de que las devoluciones de llamada intenten cancelarse entre s\u00ed mientras se ejecutan en paralelo."
        }
    ],
    "metrics": {
        "cvssMetricV31": [
            {
                "source": "nvd@nist.gov",
                "type": "Primary",
                "cvssData": {
                    "version": "3.1",
                    "vectorString": "CVSS:3.1\/AV:L\/AC:L\/PR:L\/UI:N\/S:U\/C:N\/I:N\/A:H",
                    "baseScore": 5.5,
                    "baseSeverity": "MEDIUM",
                    "attackVector": "LOCAL",
                    "attackComplexity": "LOW",
                    "privilegesRequired": "LOW",
                    "userInteraction": "NONE",
                    "scope": "UNCHANGED",
                    "confidentialityImpact": "NONE",
                    "integrityImpact": "NONE",
                    "availabilityImpact": "HIGH"
                },
                "exploitabilityScore": 1.8,
                "impactScore": 3.6
            }
        ]
    },
    "weaknesses": [
        {
            "source": "nvd@nist.gov",
            "type": "Primary",
            "description": [
                {
                    "lang": "en",
                    "value": "CWE-667"
                }
            ]
        }
    ],
    "configurations": [
        {
            "nodes": [
                {
                    "operator": "OR",
                    "negate": false,
                    "cpeMatch": [
                        {
                            "vulnerable": true,
                            "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
                            "versionStartIncluding": "5.15",
                            "versionEndExcluding": "6.6.41",
                            "matchCriteriaId": "DA87C02E-A4BF-4FD7-AE47-A2AB23061A91"
                        },
                        {
                            "vulnerable": true,
                            "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*",
                            "versionStartIncluding": "6.7",
                            "versionEndExcluding": "6.9.10",
                            "matchCriteriaId": "AB2E8DEC-CFD5-4C2B-981D-E7E45A36C352"
                        }
                    ]
                }
            ]
        }
    ],
    "references": [
        {
            "url": "https:\/\/git.kernel.org\/stable\/c\/3e4e8178a8666c56813bd167b848fca0f4c9af0a",
            "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
            "tags": [
                "Patch"
            ]
        },
        {
            "url": "https:\/\/git.kernel.org\/stable\/c\/9369830518688ecd5b08ffc08ab3302ce2b5d0f7",
            "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
            "tags": [
                "Patch"
            ]
        },
        {
            "url": "https:\/\/git.kernel.org\/stable\/c\/d4523831f07a267a943f0dde844bf8ead7495f13",
            "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
            "tags": [
                "Patch"
            ]
        }
    ]
}